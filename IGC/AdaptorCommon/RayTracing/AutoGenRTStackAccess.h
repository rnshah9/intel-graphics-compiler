/*========================== begin_copyright_notice ============================

Copyright (C) 2019-2022 Intel Corporation

SPDX-License-Identifier: MIT

============================= end_copyright_notice ===========================*/


// This file is autogenerated.  It is not currently part of the build process as
// we don't expect to update that often.

#include "Probe/Assertion.h"
#include "llvmWrapper/IR/Module.h"

static Type* _gettype_RTStack2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::RTStack"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::HWRayData"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                };
                return StructType::create(M.getContext(), Tys, "union.anon", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.0", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.2", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
          }(),
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                };
                return StructType::create(M.getContext(), Tys, "union.anon", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.0", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.2", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
          }(),
          [&]() {
            auto *EltTy =
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemRay"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.4", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.6", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.8", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.10", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemRay", false);
              }();
            return ArrayType::get(EltTy, 2);
          }(),
          [&]() {
            auto *EltTy =
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemTravStack"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          IntegerType::get(M.getContext(), 64),
                          IntegerType::get(M.getContext(), 32),
                          [&]() {
                            auto *EltTy =
                              IntegerType::get(M.getContext(), 32);
                            return ArrayType::get(EltTy, 4);
                          }(),
                          [&]() {
                            auto *EltTy =
                              [&]() {
                                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::NodeInfo"))
                                  return Ty;
                                SmallVector<Type*, 4> Tys {
                                  IntegerType::get(M.getContext(), 8),
                                };
                                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::NodeInfo", false);
                              }();
                            return ArrayType::get(EltTy, 4);
                          }(),
                        };
                        return StructType::create(M.getContext(), Tys, "struct.anon.14", false);
                      }(),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.12", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemTravStack", false);
              }();
            return ArrayType::get(EltTy, 2);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::HWRayData", false);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::RTStack", false);
  }();
}

static Type* _gettype_HWRayData2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::HWRayData"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.0", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.2", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
      }(),
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.0", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.2", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemRay"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.4", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.6", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.8", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.10", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemRay", false);
          }();
        return ArrayType::get(EltTy, 2);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemTravStack"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                SmallVector<Type*, 4> Tys {
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                      IntegerType::get(M.getContext(), 32),
                      [&]() {
                        auto *EltTy =
                          IntegerType::get(M.getContext(), 32);
                        return ArrayType::get(EltTy, 4);
                      }(),
                      [&]() {
                        auto *EltTy =
                          [&]() {
                            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::NodeInfo"))
                              return Ty;
                            SmallVector<Type*, 4> Tys {
                              IntegerType::get(M.getContext(), 8),
                            };
                            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::NodeInfo", false);
                          }();
                        return ArrayType::get(EltTy, 4);
                      }(),
                    };
                    return StructType::create(M.getContext(), Tys, "struct.anon.14", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.12", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemTravStack", false);
          }();
        return ArrayType::get(EltTy, 2);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::HWRayData", false);
  }();
}

static Type* _gettype_RayQueryObject2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::RayQueryObject"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::RTStack"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::HWRayData"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 32),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.0", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.2", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
              }(),
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 32),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.0", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.2", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
              }(),
              [&]() {
                auto *EltTy =
                  [&]() {
                    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemRay"))
                      return Ty;
                    SmallVector<Type*, 4> Tys {
                      [&]() {
                        auto *EltTy =
                          Type::getFloatTy(M.getContext());
                        return ArrayType::get(EltTy, 3);
                      }(),
                      [&]() {
                        auto *EltTy =
                          Type::getFloatTy(M.getContext());
                        return ArrayType::get(EltTy, 3);
                      }(),
                      Type::getFloatTy(M.getContext()),
                      Type::getFloatTy(M.getContext()),
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          IntegerType::get(M.getContext(), 64),
                        };
                        return StructType::create(M.getContext(), Tys, "union.anon.4", false);
                      }(),
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          IntegerType::get(M.getContext(), 64),
                        };
                        return StructType::create(M.getContext(), Tys, "union.anon.6", false);
                      }(),
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          IntegerType::get(M.getContext(), 64),
                        };
                        return StructType::create(M.getContext(), Tys, "union.anon.8", false);
                      }(),
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          IntegerType::get(M.getContext(), 64),
                        };
                        return StructType::create(M.getContext(), Tys, "union.anon.10", false);
                      }(),
                    };
                    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemRay", false);
                  }();
                return ArrayType::get(EltTy, 2);
              }(),
              [&]() {
                auto *EltTy =
                  [&]() {
                    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemTravStack"))
                      return Ty;
                    SmallVector<Type*, 4> Tys {
                      [&]() {
                        SmallVector<Type*, 4> Tys {
                          [&]() {
                            SmallVector<Type*, 4> Tys {
                              IntegerType::get(M.getContext(), 64),
                              IntegerType::get(M.getContext(), 32),
                              [&]() {
                                auto *EltTy =
                                  IntegerType::get(M.getContext(), 32);
                                return ArrayType::get(EltTy, 4);
                              }(),
                              [&]() {
                                auto *EltTy =
                                  [&]() {
                                    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::NodeInfo"))
                                      return Ty;
                                    SmallVector<Type*, 4> Tys {
                                      IntegerType::get(M.getContext(), 8),
                                    };
                                    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::NodeInfo", false);
                                  }();
                                return ArrayType::get(EltTy, 4);
                              }(),
                            };
                            return StructType::create(M.getContext(), Tys, "struct.anon.14", false);
                          }(),
                        };
                        return StructType::create(M.getContext(), Tys, "union.anon.12", false);
                      }(),
                    };
                    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemTravStack", false);
                  }();
                return ArrayType::get(EltTy, 2);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::HWRayData", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::RTStack", false);
      }(),
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::RayQueryStateInfo"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 8),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::RayQueryStateInfo", false);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::RayQueryObject", false);
  }();
}

static Type* _gettype_SMStack2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::SMStack"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::SMRayData"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                };
                return StructType::create(M.getContext(), Tys, "union.anon", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.0", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.2", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
          }(),
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                };
                return StructType::create(M.getContext(), Tys, "union.anon", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.0", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.2", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
          }(),
          [&]() {
            auto *EltTy =
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemRay"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  Type::getFloatTy(M.getContext()),
                  Type::getFloatTy(M.getContext()),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.4", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.6", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.8", false);
                  }(),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 64),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.10", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemRay", false);
              }();
            return ArrayType::get(EltTy, 2);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::SMRayData", false);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::SMStack", false);
  }();
}

static Type* _gettype_SMRayData2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::SMRayData"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.0", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.2", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
      }(),
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemHit"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          Type::getFloatTy(M.getContext()),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.0", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.2", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemHit", false);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::MemRay"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              Type::getFloatTy(M.getContext()),
              Type::getFloatTy(M.getContext()),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.4", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.6", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.8", false);
              }(),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.10", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::MemRay", false);
          }();
        return ArrayType::get(EltTy, 2);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::SMRayData", false);
  }();
}

static Type* _gettype_SWHotZone_v1(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::SWHotZone_v1"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::StackPtrDRIEncoding"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::StackPtrAndBudges"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 16),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 16),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.15", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::StackPtrAndBudges", false);
          }(),
          IntegerType::get(M.getContext(), 32),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::StackPtrDRIEncoding", false);
      }(),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 8);
        return ArrayType::get(EltTy, 8);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::SWHotZone_v1", false);
  }();
}

static Type* _gettype_SWHotZone_v2(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::SWHotZone_v2"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      IntegerType::get(M.getContext(), 32),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 32);
        return ArrayType::get(EltTy, 3);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::SWHotZone_v2", false);
  }();
}

static Type* _gettype_RayDispatchGlobalData(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.IGC::RayDispatchGlobalData"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      [&]() {
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
        };
        return StructType::create(M.getContext(), Tys, "union.anon.17", false);
      }(),
      [&]() {
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
        };
        return StructType::create(M.getContext(), Tys, "union.anon.19", false);
      }(),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 64),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 32);
        return ArrayType::get(EltTy, 3);
      }(),
      IntegerType::get(M.getContext(), 32),
    };
    return StructType::create(M.getContext(), Tys, "struct.IGC::RayDispatchGlobalData", false);
  }();
}

static Type* _gettype_InstanceLeaf(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf::Part0"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.21", false);
          }(),
          IntegerType::get(M.getContext(), 64),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf::Part0", false);
      }(),
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf::Part1"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
          [&]() {
            auto *EltTy =
              Type::getFloatTy(M.getContext());
            return ArrayType::get(EltTy, 3);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf::Part1", false);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf", false);
  }();
}

static Type* _gettype_QuadLeaf(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::QuadLeaf"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::PrimLeafDesc"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.23", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::PrimLeafDesc", false);
      }(),
      IntegerType::get(M.getContext(), 32),
      [&]() {
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
        };
        return StructType::create(M.getContext(), Tys, "union.anon.25", false);
      }(),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::QuadLeaf", false);
  }();
}

static Type* _gettype_ProceduralLeaf(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::ProceduralLeaf"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::PrimLeafDesc"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 32),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.23", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::PrimLeafDesc", false);
      }(),
      IntegerType::get(M.getContext(), 32),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 32);
        return ArrayType::get(EltTy, 13);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::ProceduralLeaf", false);
  }();
}

static Type* _gettype_RTGlobalsAndRootSig(Module &M, Type* TypeHoleGlobalRootSig)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.IGC::RTGlobalsAndRootSig"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.IGC::RayDispatchGlobalData"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.17", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 32),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.19", false);
          }(),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 64),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          IntegerType::get(M.getContext(), 32),
          [&]() {
            auto *EltTy =
              IntegerType::get(M.getContext(), 32);
            return ArrayType::get(EltTy, 3);
          }(),
          IntegerType::get(M.getContext(), 32),
        };
        return StructType::create(M.getContext(), Tys, "struct.IGC::RayDispatchGlobalData", false);
      }(),
      [&]() {
        IGC_ASSERT_MESSAGE(checkAlign(M, cast<StructType>(TypeHoleGlobalRootSig), 8), "type not aligned!");
        return TypeHoleGlobalRootSig;
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.IGC::RTGlobalsAndRootSig", false);
  }();
}

static Type* _gettype_ShaderRecord(Module &M, Type* TypeHoleLocalRootSig)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::ShaderRecord"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      [&]() {
        if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::ShaderIdentifier"))
          return Ty;
        SmallVector<Type*, 4> Tys {
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::KSP"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::KSP", false);
          }(),
          [&]() {
            SmallVector<Type*, 4> Tys {
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::KSP"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::KSP", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "union.anon.27", false);
          }(),
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::KSP"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::KSP", false);
          }(),
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::KSP"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              IntegerType::get(M.getContext(), 64),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::KSP", false);
          }(),
        };
        return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::ShaderIdentifier", false);
      }(),
      [&]() {
        IGC_ASSERT_MESSAGE(checkAlign(M, cast<StructType>(TypeHoleLocalRootSig), 32), "type not aligned!");
        return TypeHoleLocalRootSig;
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::ShaderRecord", false);
  }();
}

static Type* _gettype_BVH(Module &M)
{
  return
  [&]() {
    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::BVH"))
      return Ty;
    SmallVector<Type*, 4> Tys {
      IntegerType::get(M.getContext(), 64),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
      [&]() {
        auto *EltTy =
          Type::getFloatTy(M.getContext());
        return ArrayType::get(EltTy, 3);
      }(),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      IntegerType::get(M.getContext(), 32),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InternalNode"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              IntegerType::get(M.getContext(), 32),
              IntegerType::get(M.getContext(), 8),
              IntegerType::get(M.getContext(), 8),
              IntegerType::get(M.getContext(), 8),
              IntegerType::get(M.getContext(), 8),
              IntegerType::get(M.getContext(), 8),
              IntegerType::get(M.getContext(), 8),
              [&]() {
                auto *EltTy =
                  [&]() {
                    if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InternalNode::ChildData"))
                      return Ty;
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 8),
                    };
                    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InternalNode::ChildData", false);
                  }();
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 8);
                return ArrayType::get(EltTy, 6);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InternalNode", false);
          }();
        return ArrayType::get(EltTy, 1);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::QuadLeaf"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::PrimLeafDesc"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 32),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.23", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::PrimLeafDesc", false);
              }(),
              IntegerType::get(M.getContext(), 32),
              [&]() {
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                };
                return StructType::create(M.getContext(), Tys, "union.anon.25", false);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
              [&]() {
                auto *EltTy =
                  Type::getFloatTy(M.getContext());
                return ArrayType::get(EltTy, 3);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::QuadLeaf", false);
          }();
        return ArrayType::get(EltTy, 1);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::ProceduralLeaf"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::PrimLeafDesc"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 32),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.23", false);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::PrimLeafDesc", false);
              }(),
              IntegerType::get(M.getContext(), 32),
              [&]() {
                auto *EltTy =
                  IntegerType::get(M.getContext(), 32);
                return ArrayType::get(EltTy, 13);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::ProceduralLeaf", false);
          }();
        return ArrayType::get(EltTy, 1);
      }(),
      [&]() {
        auto *EltTy =
          [&]() {
            if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf"))
              return Ty;
            SmallVector<Type*, 4> Tys {
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf::Part0"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 32),
                  [&]() {
                    SmallVector<Type*, 4> Tys {
                      IntegerType::get(M.getContext(), 32),
                    };
                    return StructType::create(M.getContext(), Tys, "union.anon.21", false);
                  }(),
                  IntegerType::get(M.getContext(), 64),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf::Part0", false);
              }(),
              [&]() {
                if (auto *Ty = IGCLLVM::getTypeByName(M, "struct.RTStackFormat::InstanceLeaf::Part1"))
                  return Ty;
                SmallVector<Type*, 4> Tys {
                  IntegerType::get(M.getContext(), 64),
                  IntegerType::get(M.getContext(), 32),
                  IntegerType::get(M.getContext(), 32),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                  [&]() {
                    auto *EltTy =
                      Type::getFloatTy(M.getContext());
                    return ArrayType::get(EltTy, 3);
                  }(),
                };
                return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf::Part1", false);
              }(),
            };
            return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::InstanceLeaf", false);
          }();
        return ArrayType::get(EltTy, 1);
      }(),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 32);
        return ArrayType::get(EltTy, 1);
      }(),
      [&]() {
        auto *EltTy =
          IntegerType::get(M.getContext(), 8);
        return ArrayType::get(EltTy, 124);
      }(),
    };
    return StructType::create(M.getContext(), Tys, "struct.RTStackFormat::BVH", false);
  }();
}

Value* _gepof_rtMemBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_callStackHandlerPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_stackSizePerRay(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(2),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_numDSSRTStacks(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(3),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_maxBVHLevels(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(4),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_paddingBits(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(5),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_hitGroupBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(6),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_missShaderBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(7),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_callableShaderBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(8),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_hitGroupStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(9),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_missShaderStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(10),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_callableShaderStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(11),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_printfBufferBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(13),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_statelessScratchPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(15),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pCallableShaderBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(16),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pCallableShaderStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(17),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_bindlessHeapBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(19),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pHitGroupBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(20),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pMissShaderBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(21),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pHitGroupStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(22),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pMissShaderStride(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(23),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pRtMemBasePtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(24),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pStackSizePerRay(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(26),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_swStackSizePerRay(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(27),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_pNumDSSRTStacks(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(28),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_baseSSHOffset(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(25),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_BVH_rootNodeOffset(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_dispatchRaysDimensions(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(29),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_dispRaysIndex_v2(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_StackOffset_v2(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CompressedDispatchRayIndices_v1(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_StackOffset_v1(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_BudgeBits_v1(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitT(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitT2(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitT(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitU(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitU(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitTopOfInstLeafPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(5),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitTopOfInstLeafPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(5),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitTopOfPrimLeafPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(4),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitTopOfPrimLeafPtr(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(4),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitTopOfPrimIndexDelta(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(3),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitTopOfPrimIndexDelta(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(3),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_CommittedHitFrontFaceDword(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(3),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_PotentialHitFrontFaceDword(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(3),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_topOfNodePtrAndFlags(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(4),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_hitGroupShaderRecordInfo(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(5),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_missShaderRecordInfo(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(6),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_topOfInstanceLeafPtr(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(7),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_MemRay_org(Value* p, Value* idx1, Value* idx2, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(0),
    idx2,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_MemRay_dir(Value* p, Value* idx1, Value* idx2, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(1),
    idx2,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_MemRay_tnear(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(2),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_MemRay_tfar(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(2),
    idx1,
    this->getInt32(3),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_RQO_rtStack(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_RQO_TRCtrl(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_instanceID(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_instanceIndex(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(2),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_world2obj_vx(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(3),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_world2obj_vy(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(4),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_world2obj_vz(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(5),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_obj2world_p(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(6),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_obj2world_vx(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(3),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_obj2world_vy(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(4),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_obj2world_vz(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(5),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_world2obj_p(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(6),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_InstanceLeaf_instContToHitGroupIndex(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_QuadLeaf_primIndex0(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_QuadLeaf_topOfGeomIndex(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_ProceduralLeaf__primIndex(Value* p, Value* idx1, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(2),
    idx1,
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_ProceduralLeaf_topOfGeomIndex(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(0),
    this->getInt32(1),
    this->getInt32(0),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

Value* _gepof_ShaderRecord_LocalRootSig(Value* p, const Twine &Name = "")
{
  Value* Indices[] = {
    this->getInt32(0),
    this->getInt32(1),
  };
  return this->CreateInBoundsGEP(p, Indices, Name);
}

